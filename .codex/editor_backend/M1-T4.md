# M1-T4 â€“ Repository Integration Tests (Testcontainers)

## Goal
Verify the newly added editor repositories against a real PostgreSQL instance using Spring Boot + Testcontainers.

## Planned Steps
1. Inspect existing integration test infrastructure (e.g., `IntegrationTestBase`) to understand how Testcontainers is configured.
2. Create integration test classes for `DocumentNodeRepository`, `DocumentRevisionRepository`, and `DocumentMetadataRepository`.
3. Seed minimal tenants/workspaces/documents within tests to exercise CRUD operations, unique constraints, and tenant/workspace scoping.
4. Cover edge cases: slug/path uniqueness, revision ordering, metadata JSON/tags persistence.
5. Run integration tests (or document inability due to sandbox) and note results.

## Notes
- Reuse helper methods for tenant/workspace creation if available; otherwise create direct inserts in tests.
- Ensure tests clean up data between runs (Postgres container resets per test class).
- Align naming conventions with existing integration test suite.

## Progress
- Added `DocumentRepositoryIntegrationTest` covering node hierarchy persistence, revision ordering, metadata JSON/tags, and uniqueness checks via Testcontainers context.
- Utilized `IntegrationTestBase` utilities with explicit seed helpers for tenants/users/workspaces.
- Adjusted repository implementations to rely on array-based `JdbcTemplate` calls to avoid Kotlin intersection warnings.

## Blockers / Follow-ups
- Gradle integration tests pass locally (outside sandbox); current environment cannot re-run due to Gradle IP restrictions, so rerun `./gradlew test --tests "*DocumentRepositoryIntegrationTest"` locally to verify.
