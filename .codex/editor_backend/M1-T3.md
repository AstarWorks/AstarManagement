# M1-T3 â€“ Domain Models & Repository Implementations

## Goal
Define the core domain models (DocumentNode, DocumentRevision, DocumentMetadata) and their Spring Data JDBC repositories, ensuring alignment with the new schema.

## Planned Steps
1. Design Kotlin domain data classes mirroring the schema with value objects for IDs/paths where useful.
2. Implement Spring Data JDBC repositories (interfaces + custom queries) for nodes, revisions, metadata.
3. Add mapper/converter utilities if needed for JSONB/array handling (reuse existing patterns like `BaseJsonbRepository`).
4. Wire repositories into the editor package structure and ensure configuration picks them up.
5. Record progress and blockers; tests will be added in later tasks.

## Notes
- Keep entities focused on M1 plaintext scope; encryption logic remains out of scope.
- Plan for optimistic locking/versioning at service layer later.
- Ensure tenant/workspace scoping is explicit in repository APIs.

## Progress
- Added editor domain models (`DocumentNode`, `DocumentRevision`, `DocumentMetadata`, and `DocumentNodeType`) reflecting the V026 schema with validation helpers.
- Updated shared `DomainIds` to include strongly typed IDs for document nodes and revisions.
- Created repository interfaces for nodes, revisions, and metadata exposing tenant/workspace scoped access patterns.
- Implemented JDBC-based repository classes and mappers handling JSONB, arrays, and binary columns under `core/editor/infrastructure/persistence`.

## Blockers / Follow-ups
- Need integration tests (Task M1-T4) to confirm repositories operate correctly against Postgres.
- Gradle build/test not executed here due to sandbox Gradle IP restrictions; run `./gradlew test` or targeted checks locally once repository tests are added.
